# 4.1.9 性能测试

- 测试场景一：在10、100、1000、10000个元素情况下，对ArrayList、LinkedList、Vector、Stack、HashSet、TreeSet、HashMap、TreeMap的运行时间求平均值对比
	- 情况：可以看出，当元素数量上升至10000后，插入元素时除ArrayList、Vector扩容影响较大外，其他集合类基本没有变化。在查找、删除元素上，几个List的实现性能下降较大，而Set、Map基本不会瘦元素数量的影响
	- 结论：所以对于查找和删除较为频繁，且元素数量较多的应用，Set或Map时更好的选择，而对于其他场景，则可以根据需要的数据结构来进行相应的选择
- 测试场景二：在10、100、1000、10000的不同集合大小以及不同线程数（10，50，100）的情况下，增加、查找以及删除100个元素的性能变化情况
	- 情况：仍然时LinkedList表现稍差，但当元素数量上涨到10000后，各集合类的操作的相应速度均大幅度下降。从整体爱看，在多线程的场景下，各集合类的性能较之单线程而言都大幅度下降，单在元素数量为1000左右，性能的影响因素主要取决于擦欧总的线程数。线程数越多，性能下降得越多，Set和Map得实现在各种场景下表现均更出色，随着元素或线程数增多，LinkedList在性能上表现得则相对差一些
- 小结
	- 场景中选择适合的集合类，第一，根据功能需求来选择是用List、Set还是Map
		- List适合允许重复元素的单个对象集合场景
		- Set适用于不允许重复元素的单个对象集合场景
		- Map适用于key-value结构的集合场景
	- 第二、在选择好List、Set或Map时，就要选择实现类了
		- List
			- ArrayList适合要通过位置来读取元素的场景
			- LinkedList适合要头尾操作以及插入指定位置的场景
			- Vector适合要线程安全的ArrayList
			- Stack适合县城俺去拿的LIFO场景，如需要支持FIFO
		- Set
			- HashSet适合对排序没有要求的场景
			- TreeSet适合需要排序的非重复元素的存储
		- Map
			- HashMap适合用于大部分key-value的存储场景
			- TreeMap适合用于排序存放的key-value的场景
		- 此外，还可以根据特殊需要，或其他的一些Sun JDK类库中的类，例如HashTable、LinkedHashSet等